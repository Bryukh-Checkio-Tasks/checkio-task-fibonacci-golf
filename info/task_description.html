<div class="story">
    <p>
        The <a href="http://oeis.org/">On-Line Encyclopedia of Integer Sequences</a> (OEIS), also cited simply as
        Sloane's, is an online database of
        integer sequences. It was created and maintained by Neil Sloane while a researcher at AT&T Labs. Foreseeing his
        retirement from AT&T Labs in 2012 and the need for an independent foundation, Sloane agreed to transfer the
        intellectual property and hosting of the OEIS to the OEIS Foundation in October 2009. Sloane continues to be
        involved in the OEIS in his role as President of the OEIS Foundation.<br>
        -- Wikipedia.
    </p>

    <p>
        To celebrate the launching of The OEIS Foundation Inc,
        Tony Noe has made an 8.5-minute movie showing graphs of the first 1000 terms of 1000 sequences,
        with soundtrack from Recaman's sequence A005132.<br>
        <a href="http://www.youtube.com/watch?v=LCWglXljevY">The OEIS Movie</a> on Youtube.<br>
        -- OEIS, Welcome page.

    </p>
</div>

<p>
    <a href="http://en.wikipedia.org/wiki/Fibonacci_numbers">The Fibonacci numbers</a> or
    Fibonacci sequence are the numbers in the following integer sequence:<br>
    0, 1, 1, 2, 3, 5, 8, 13, 21...<br>
    This is not the only interesting integer sequence however; there are many various sequences like the Fibonacci
    numbers, where each element is calculated using the previous elements. Let's take a look at a few of them.
</p>

<p>
    Described below are several integer sequences which you should try to implement:

</p>
<ul>
    <li>
        <a href="http://oeis.org/A000045">fibonacci</a>:
        <pre>f(0)=0, f(1)=1, f(n)=f(n-1)+f(n-2)</pre>
    </li>
    <li>
        <a href="http://oeis.org/A000073">tribonacci</a>:
        <pre>f(0)=0, f(1)=1, f(2)=1, f(n)=f(n-1)+f(n-2)+f(n-3)</pre>
    </li>
    <li>
        <a href="http://oeis.org/A000032">lucas</a>:
        <pre>f(0)=2, f(1)=1, f(n)=f(n-1)+f(n-2)</pre>
    </li>
    <li>
        <a href="http://oeis.org/A001045">jacobsthal</a>:
        <pre>f(0)=0, f(1)=1, f(n)=f(n-1)+2*f(n-2)</pre>
    </li>
    <li>
        <a href="http://oeis.org/A000129">pell</a>:
        <pre>f(0)=0, f(1)=1, f(n)=2*f(n-1)+f(n-2)</pre>
    </li>
    <li>
        <a href="http://oeis.org/A001608">perrin</a>:
        <pre>f(0)=3, f(1)=0, f(2)=2, f(n)=f(n-2)+f(n-3)</pre>
    </li>
    <li>
        <a href="http://oeis.org/A000931">padovan</a>:
        <pre>f(0)=0, f(1)=1, f(2)=1, f(n)=f(n-2)+f(n-3)</pre>
    </li>
</ul>
<p>
    You are given the name of a sequence and a number "n".
    You should find the <strong>n-th</strong> element for that given sequence.
</p>

<p>
    In this mission the main goal is to make your code as short as possible.
    The system will check the length of your compiled code and assign a point value.
    The shorter your compiled code, the more points you earn.
    You can use <a href="https://github.com/cielavenir/checkio-task-fibonacci-golf/blob/master/local_checker.py">the
    local checker</a>
    to determine the compiled size locally.
    Your score for this mission is dynamic and directly related to the length of your code.
    For reference, scoring is based on the number of characters used.
    1000 bytes is the maximum allowable and it will earn you zero points.
    For each byte less than 1000, you earn 1 point. For example for 300 byte long code earns you 700 points.
    As for CheckiO experience points, every 2 score are worth 1 point.
</p>
<p>
    <strong>Input:</strong> Two arguments. The name of a sequence as a string and a number "n" as a positive integer.
</p>

<p>
    <strong>Output:</strong> The n-th element of the sequence as an integer.<br>

</p>


<p>
    <strong>How it is used:</strong>
    This mission teaches you the driving idea behind the Don’t Repeat Yourself (DRY) principle of software development.
    The principle is as follows: "Every piece of knowledge must have a single, unambiguous, authoritative representation
    within a system." This principle allows you to make changes to your code with uniformly predictable results. This
    principle stands in contrast to the “Write Everything Twice” (WET) principle, which is sometimes also known as the
    “We Enjoy Typing” principle.
</p>

<p>
    <strong>Preconditions:</strong>
    10 &le; n &lt; 400
</p>

<p>
    <strong>Closed builtins:</strong>
    eval, exec
</p>
